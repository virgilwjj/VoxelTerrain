#pragma kernel BuildNoiseDensityField
#include "../Include/Chunk.compute"
#include "../Include/Noise.compute"
#include "../Include/Math.compute"

float voxelSizePerAxis;
int3 minCoord;
int stridePerAxis;
RWStructuredBuffer<float> densityField;

// Noise settings
StructuredBuffer<float3> offsets;
static const int octaves = 8;
static const float lacunarity = 2;
static const float persistence = 0.54f;
static const float noiseScale = 2.71f;
static const float noiseWeight = 11.24;
static float floorOffset = 1;
static float weightMultiplier = 10;
static const bool closeEdges = false;
static float hardFloor = 0;
static float hardFloorWeight = -15;

static float4 params = float4(5.08f, 1.06f, 0.4f, -0.03f);

[numthreads(8, 8, 8)]
void BuildNoiseDensityField(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }

    int3 coord = minCoord + int3(id) * stridePerAxis;
    float3 pos = coord * voxelSizePerAxis * 0.3222;
    float offsetNoise = 0;

    float noise = 0;

    float frequency = noiseScale / 100;
    float amplitude = 1;
    float weight = 1;
    for (int j = 0; j < octaves; ++j)
    {
        float n = snoise((pos + offsetNoise) * frequency + offsets[j]);
        float v = 1 - abs(n);
        v = v * v;
        v *= weight;
        weight = min(max(0, v * weightMultiplier), 1);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    float finalVal = -(pos.y + floorOffset) + noise * noiseWeight + (pos.y % params.x) * params.y;

    if (isLowerEqual(pos.y, hardFloor)) {
        finalVal += hardFloorWeight;
    }

    uint index = getIndexById(id);
    densityField[index] = finalVal;
}
