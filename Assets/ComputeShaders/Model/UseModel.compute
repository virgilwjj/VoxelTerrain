#pragma kernel UseModel
#include "../Include/Chunk.compute"

float voxelSizePerAxis;
float isoLevel;

RWStructuredBuffer<float> densityField;
int3 minCoord;
int stridePerAxis;
StructuredBuffer<float> pointBuffer;
uint numPointsPerAxisForBrush;
int3 minCoordForBrush;

[numthreads(8, 8, 8)]
void UseModel(uint3 id : SV_DispatchThreadID)
{
    if ((id.x >= numPointsPerAxisForBrush) || (id.y >= numPointsPerAxisForBrush) || (id.z >= numPointsPerAxisForBrush))
    {
        return;
    }

    int3 offset = minCoordForBrush + int3(id) - minCoord; 

    if ((offset.x < 0) || (offset.y < 0) || (offset.z < 0))
    {
        return;
    }

    if ((uint(offset.x) % uint(stridePerAxis) != 0) || (uint(offset.y) % uint(stridePerAxis) != 0) || (uint(offset.z) % uint(stridePerAxis) != 0))
    {
        return;
    }

    uint3 idForChunk;
    idForChunk.x = uint(offset.x) / uint(stridePerAxis);
    idForChunk.y = uint(offset.y) / uint(stridePerAxis);
    idForChunk.z = uint(offset.z) / uint(stridePerAxis);

    if ((idForChunk.x >= numPointsPerAxis) || (idForChunk.y >= numPointsPerAxis) || (idForChunk.z >= numPointsPerAxis))
    {
        return;
    }

    uint indexForChunk = getIndexById(idForChunk);
    uint indexForBrush = (id.y * numPointsPerAxisForBrush + id.z) * numPointsPerAxisForBrush + id.x;
    float density = densityField[indexForChunk];
    float pointDensity = pointBuffer[indexForBrush];
    densityField[indexForChunk] = min(density, pointDensity);
}
